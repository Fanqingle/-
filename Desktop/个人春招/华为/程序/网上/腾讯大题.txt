public class Schedule { static final int R[]={10,15,23,20,6,9,7,16}; static final int O[]={2,7,8,4,5,8,6,8}; static final int N = 8; static final int M = 50; static int index[]; public Schedule() { index = new int[N]; }int part(int s,int e) { int p = R[e]-O[e]; int l = s; int h = e; int tmp = 0; while(l<h) { while(l<h&&(R[l]-O[l])<=p) l++; /* save the sorted sequence if necessary tmp = index[l]; index[l]=index[h]; index[h]=tmp; */ tmp =R[l]; R[l]=R[h]; R[h]=tmp; tmp = O[l]; O[l]=O[h]; O[h]=tmp; while(l<h&&(R[h]-O[h])>=p) h--; /* save the sorted sequetmp =R[l]; R[l]=R[h]; R[h]=tmp; tmp = O[l]; O[l]=O[h]; O[h]=tmp;  } return l; }void qsort(int s,int e) { if(s<e) { int pos = part(s,e); qsort(s,pos-1); qsort(pos+1,e); }void display() { int i =0; for(i=N-1;i>=0;i--) { System.out.println(R[i]+" "+O[i]); } }int sum() { int sum = 0; int i = 0; for(i = 0;i<N;i++) sum += O[i]; return sum; }public static void main(String[] args) {  Schedule t = new Schedule(); int i = 0; for(i = 0;i<N;i++) index[i]=i; t.qsort(0,N-1); int sum = t.sum(); int left = M - sum; i = 0; int min = R[i]-O[i]; while(left >= min )//left >= min(R[i]-O[i]) { left += O[index[i]]; i ++; if(i>=N) break; min = R[i]-O[i]; } if(i == N) t.display(); else System.out.prelse System.out.println("cant be scheduled"); }}假设可以满足所有请求，并且处理请求的顺序是:r1,r2,……r(n-1),r(n)，那么存储完所有的请求结果后，剩余的存储空间为L= m-∑O[i]。如果假设成立，必须满足：针对请求r(n)，一定有L+O[r(n)]>=R[r(n)]。同理，针对r(n-1)，一定有L+O[r(n)] + O[r(n-1)] >= R[r(n-1)]，依次类推。于是，证明假设成立就转化为：针对假设中的每一个请求r，都有L+∑O[r(n-j)]>=R[r]，其中i>=j>=0。相应的，原问题也就转化成从寻找这样的r。既然如此，从寻找r(n)开始，这时候有n个选择(R[1]~R[n])，那么选择哪一个呢？如上所说，我们选择的原则是满足L+O[r(n)]>=R[r(n)]，即L>=R[r(n)]-O[r(n)]。所以将所有的选择按照R[r(n)]-O[r(n)]从小到大排序，每次选择时试探R[r(n)]-O[r(n)]最小的值，如果最小值都不能满足，那么已经证明假设不成立，否则继续探测n-1，n-2……1，直到出现不能满足的情况，或者证明假设成立。